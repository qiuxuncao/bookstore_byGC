# 技术栈

- 数据库：MySQL, Redis
- Web框架：Django -----> 可以升级到Django Rest Framework，只做接口
- 服务器：Nginx
- 前端：jQuery, Ajax -----> 可以升级到Vue全家桶，前后端分离
- 消息队列：Celery
- 搜索引擎：Whoosh ----> 可以升级到ElasticSearch
- 工作流：Git Flow
- 部署：阿里云
- 运维脚本：Shell

# 项目模块

## 账户系统

username | password | email | is_active |
---------|----------|-------|-----------|
名字      | 密码     | 邮件地址| 是否激活   |

## 物流系统

recipient_name | recipient_addr | zip_code | recipient_phone | is_default | passport |
---------------|---------------|----------|---------------|----------|------------|
收件人姓名| 收件人地址 | 邮编 | 收件人电话 | 是否为默认地址 | 外键 |

## 商品系统

name | desc | price | unit | stock | sales | detail | image | status | type_id |
-----|------|----|-----|------|-------|---------|-------|-------|--------|
商品名称 | 商品描述 | 商品价格 | 单位 | 商品库存 | 商品销量 | 商品详情 | 商品图片 | 商品上下架状态 | 商品类别 |

## 订单系统

### 订单信息表

order_id | passport | addr | total_count | total_price | transit_price | pay_method | trade_id |
---------|----------|------|-------------|-------------|---------------|------------|----------|
时间戳+passport_id，主键 | 外键 | 外键 | 总数     |   总价格     |   运费         | 支付方式    | 交易ID，给支付宝用的 |

### 订单商品表

order | books | count | price |
------|-------|-------|-------|
外键   |  外键 | 数量   | 价格   |

## 购物车

使用redis实现。

原因：购物车数据经常变动，不一定要存储在MySQL中。

```py
{
    "cart_%s" % passport.id: {        # 购物车的key
        "book_id1": count,
        "book_id2": count,
    }
}
```

## 缓存策略：

使用Redis缓存一些经常访问的页面，比如首页，详情页等等。

最近浏览功能也适用Redis实现，因为最近浏览功能变化页比较频繁。

## Nginx

反向代理

负载均衡（upstream，proxy_pass）

静态文件托管（动静分离）

## 邮件和短信模块

使用第三方服务

由于是同步操作，所以放到Celery消息队列中执行。

## 鉴权方式

开始：服务端渲染，使用Cookie/Session模式鉴权。

之后：前后端分离，使用JWT进行鉴权。

## 限流和封禁IP

Django中间件实现。

## 支付

测试环境使用支付宝沙箱。

主要使用第三方python sdk。

## 第三方登陆

social-django第三方包。

OAuth（开放授权）是一个开放标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。
OAuth允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。
OAuth是OpenID的一个补充，但是完全不同的服务。

拿QQ做例子，简单说一下流程：

当用户点击QQ登陆，你会通引导用户跳转到第三方登陆的登陆界面， 当用户成功登录以后会自动跳转回来，并附带一个code参数，接着你使用code就可以获得access token（访问令牌），对于QQ，由于第三方登录结合了Openid， 所以需要再通过token获取openid。

## 日志模块

在需要log的视图函数中做log。

供数据分析师计算日活、月活，留存数据。

供开发排查线上bug。

## 后台系统

xadmin模块，配合权限管理来给公司不同的部门分配权限。

如果是自己开的电商网站，需要自己公司的运营去上传商品信息。

# 工作流程

## 与产品经理和运营的合作

1. 产品经理和运营会确定需求。
2. 产品经理和开发讨论需求。
3. 产品经理使用axure等工具出原型图，UI设计根据原型图出设计图。
4. 确定需求以后，开发设计数据库表结构，前端和后端分别开发。

## 人数

- 产品经理：1人
- 运营：N人
- 前端：1人
- iOS：1人
- Android：1人
- 后端：2人
- 设计：1人

## 完全开始一个新项目

1. GitHub或者Gitlab新建仓库，并clone到本地。
2. 开发。

## 维护旧项目（与他人合作）

1. 将项目的代码clone到本地。
2. 新建一个分支用来fix bug或者开发新的feature。
3. 将新分支的代码在测试环境测试通过。
4. 将新建的分支push到远程仓库，并提出pull request/merge request，合并到master分支的请求。
5. team leader审核合并请求的代码。
6. 如果审核通过，将代码何入master分支，并将新的代码部署上线。
7. 如果没有通过，则重复步骤2。

# 服务器数量

## 典型电商

- MySQL(主)：1台
- MySQL(从)：1台
- Redis(主)：1台
- Redis(从)：1台
- Nginx：1台
- Django：N台
- Celery：可以部署到单独的机器上，也可以不单独部署。


## 管理后台

- MySQL: 1台
- Django：1台
- Redis：1台（可选）

# 开发感想

1. 数据库的表结构的设计非常重要，尽量在前期做好设计。
2. 写增删改查时，无论写sql语句还是orm语句，尽量多考虑性能问题，避免写出耗时过长的查询。
3. 多考虑缓存策略。对redis的各种使用。
4. 要多写代码，来者不拒，尽量成为一名全栈。
5. 和产品要详细的讨论清楚需求，避免后期返工。

# 难题

1. 当今网站的瓶颈在于数据库，所以做好缓存策略至关重要，瓶颈不在语言，要把经常被访问的热点数据，放在缓存中。
2. 面对高并发场景，例如秒杀，使用队列将海量请求缓存下来，避免对数据库造成太大的压力。
